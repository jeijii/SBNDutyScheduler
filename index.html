<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SBN Duty Scheduler</title>
    <style>
      html,
      body {
        margin: 0;
        font-family: "calibri", sans-serif;
      }
      #navbar {
        padding: 3px;
        width: 100%;
        background-color: #2196f3;
        margin: 0;
        font-size: 10px;
      }
      #dropzone {
        margin: 0 auto;
        margin-top: 100px;
        height: 200px;
        width: 400px;
        border: 1px solid black;
        text-align: center;
      }
      #footer {
        position: fixed;
        bottom: 0;
        width: 100%;
        background-color: #2196f3;
        padding: 0px;
        margin: 0;
        text-align: center;
      }
      #footer p {
        padding: 0px;
        margin: 0;
      }

      table,
      tr,
      td {
        border: 1px solid black;
        margin: 0, auto;
        padding: 0px;
        border-collapse: collapse;
      }
      td {
        padding: 5px;
      }
      table {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="navbar">
      <h1>SBN Duty Scheduler</h1>
    </div>
    <div
      id="dropzone"
      ondrop="dropHandler(event);"
      ondragover="dragOverHandler(event)"
    >
      <p>Drop Preferences Files Here.</p>
    </div>
    <div id="editor"></div>
    <div id="footer">
      <p id="console">Ready</p>
    </div>
    <script>
      const COST_VALUES = [0, 1, 4, 9, 16];
      const OUT_OF_PREFERENCE_COST = 36;
      const EXCLUDED_DATES_COST = 999;
      const names = [];
      const responses = [];
      const excluded = [];
      const excludedResponses = [];
      const noOfDuty = [];
      const totalScores = [];
      const totalNames = [];
      let totalDuty = 0;
      const preferences = [];
      let schedule;
      function lap(dim, cost) {
        //from https://github.com/Fil/lap-jv
        //thank you to whoever made it i love u
        // input:
        // dim        - problem size
        // cost       - cost callback (or matrix)

        // output:
        // rowsol     - column assigned to row in solution
        // colsol     - row assigned to column in solution
        // u          - dual variables, row reduction numbers
        // v          - dual variables, column reduction numbers

        // convert the cost matrix (old API) to a callback (new API)
        if (typeof cost === "object") {
          var cost_matrix = cost;
          cost = function (i, j) {
            return cost_matrix[i][j];
          };
        }

        var sum = 0;
        {
          let i1, j1;
          for (i1 = 0; i1 < dim; i1++) {
            for (j1 = 0; j1 < dim; j1++) sum += cost(i1, j1);
          }
        }
        const BIG = 10000 * (sum / dim);
        const epsilon = sum / dim / 10000;
        const rowsol = new Int32Array(dim),
          colsol = new Int32Array(dim),
          u = new Float64Array(dim),
          v = new Float64Array(dim);
        let unassignedfound;
        /* row */
        let i,
          imin,
          numfree = 0,
          prvnumfree,
          f,
          i0,
          k,
          freerow; // *pred, *free
        /* col */
        let j, j1, j2, endofpath, last, low, up; // *collist, *matches
        /* cost */
        let min, h, umin, usubmin, v2; // *d

        const free = new Int32Array(dim); // list of unassigned rows.
        const collist = new Int32Array(dim); // list of columns to be scanned in various ways.
        const matches = new Int32Array(dim); // counts how many times a row could be assigned.
        const d = new Float64Array(dim); // 'cost-distance' in augmenting path calculation.
        const pred = new Int32Array(dim); // row-predecessor of column in augmenting/alternating path.

        // init how many times a row will be assigned in the column reduction.
        for (i = 0; i < dim; i++) matches[i] = 0;

        // COLUMN REDUCTION
        for (
          j = dim;
          j--; // reverse order gives better results.

        ) {
          // find minimum cost over rows.
          min = cost(0, j);
          imin = 0;
          for (i = 1; i < dim; i++)
            if (cost(i, j) < min) {
              min = cost(i, j);
              imin = i;
            }
          v[j] = min;
          if (++matches[imin] == 1) {
            // init assignment if minimum row assigned for first time.
            rowsol[imin] = j;
            colsol[j] = imin;
          } else if (v[j] < v[rowsol[imin]]) {
            j1 = rowsol[imin];
            rowsol[imin] = j;
            colsol[j] = imin;
            colsol[j1] = -1;
          } else colsol[j] = -1; // row already assigned, column not assigned.
        }

        // REDUCTION TRANSFER
        for (i = 0; i < dim; i++) {
          if (
            matches[i] == 0 // fill list of unassigned 'free' rows.
          )
            free[numfree++] = i;
          else if (matches[i] == 1) {
            // transfer reduction from rows that are assigned once.
            j1 = rowsol[i];
            min = BIG;
            for (j = 0; j < dim; j++)
              if (j != j1)
                if (cost(i, j) - v[j] < min + epsilon) min = cost(i, j) - v[j];
            v[j1] = v[j1] - min;
          }
        }

        // AUGMENTING ROW REDUCTION
        let loopcnt = 0; // do-loop to be done twice.
        do {
          loopcnt++;

          // scan all free rows.
          // in some cases, a free row may be replaced with another one to be scanned next.
          k = 0;
          prvnumfree = numfree;
          numfree = 0; // start list of rows still free after augmenting row reduction.
          while (k < prvnumfree) {
            i = free[k];
            k++;

            // find minimum and second minimum reduced cost over columns.
            umin = cost(i, 0) - v[0];
            j1 = 0;
            usubmin = BIG;
            for (j = 1; j < dim; j++) {
              h = cost(i, j) - v[j];
              if (h < usubmin)
                if (h >= umin) {
                  usubmin = h;
                  j2 = j;
                } else {
                  usubmin = umin;
                  umin = h;
                  j2 = j1;
                  j1 = j;
                }
            }

            i0 = colsol[j1];
            if (umin < usubmin + epsilon)
              //         change the reduction of the minimum column to increase the minimum
              //         reduced cost in the row to the subminimum.
              v[j1] = v[j1] - (usubmin + epsilon - umin);
            else if (i0 > -1) {
              // minimum and subminimum equal.
              // minimum column j1 is assigned.
              // swap columns j1 and j2, as j2 may be unassigned.
              j1 = j2;
              i0 = colsol[j2];
            }

            // (re-)assign i to j1, possibly de-assigning an i0.
            rowsol[i] = j1;
            colsol[j1] = i;

            if (i0 > -1)
              if (umin < usubmin)
                // minimum column j1 assigned earlier.
                // put in current k, and go back to that k.
                // continue augmenting path i - j1 with i0.
                free[--k] = i0;
              // no further augmenting reduction possible.
              // store i0 in list of free rows for next phase.
              else free[numfree++] = i0;
          }
        } while (loopcnt < 2); // repeat once.

        // AUGMENT SOLUTION for each free row.
        for (f = 0; f < numfree; f++) {
          freerow = free[f]; // start row of augmenting path.

          // Dijkstra shortest path algorithm.
          // runs until unassigned column added to shortest path tree.
          for (j = dim; j--; ) {
            d[j] = cost(freerow, j) - v[j];
            pred[j] = freerow;
            collist[j] = j; // init column list.
          }

          low = 0; // columns in 0..low-1 are ready, now none.
          up = 0; // columns in low..up-1 are to be scanned for current minimum, now none.
          // columns in up..dim-1 are to be considered later to find new minimum,
          // at this stage the list simply contains all columns
          unassignedfound = false;
          do {
            if (up == low) {
              // no more columns to be scanned for current minimum.
              last = low - 1;

              // scan columns for up..dim-1 to find all indices for which new minimum occurs.
              // store these indices between low..up-1 (increasing up).
              min = d[collist[up++]];
              for (k = up; k < dim; k++) {
                j = collist[k];
                h = d[j];
                if (h <= min) {
                  if (h < min) {
                    // new minimum.
                    up = low; // restart list at index low.
                    min = h;
                  }
                  // new index with same minimum, put on undex up, and extend list.
                  collist[k] = collist[up];
                  collist[up++] = j;
                }
              }
              // check if any of the minimum columns happens to be unassigned.
              // if so, we have an augmenting path right away.
              for (k = low; k < up; k++)
                if (colsol[collist[k]] < 0) {
                  endofpath = collist[k];
                  unassignedfound = true;
                  break;
                }
            }

            if (!unassignedfound) {
              // update 'distances' between freerow and all unscanned columns, via next scanned column.
              j1 = collist[low];
              low++;
              i = colsol[j1];
              h = cost(i, j1) - v[j1] - min;

              for (k = up; k < dim; k++) {
                j = collist[k];
                v2 = cost(i, j) - v[j] - h;
                if (v2 < d[j]) {
                  pred[j] = i;
                  if (v2 == min)
                    if (colsol[j] < 0) {
                      // new column found at same minimum value
                      // if unassigned, shortest augmenting path is complete.
                      endofpath = j;
                      unassignedfound = true;
                      break;
                    } else {
                      // else add to list to be scanned right away.
                      collist[k] = collist[up];
                      collist[up++] = j;
                    }
                  d[j] = v2;
                }
              }
            }
          } while (!unassignedfound);

          // update column prices.
          for (k = last + 1; k--; ) {
            j1 = collist[k];
            v[j1] = v[j1] + d[j1] - min;
          }

          // reset row and column assignments along the alternating path.
          do {
            i = pred[endofpath];
            colsol[endofpath] = i;
            j1 = endofpath;
            endofpath = rowsol[i];
            rowsol[i] = j1;
          } while (i != freerow);
        }

        // calculate optimal cost.
        let lapcost = 0;
        for (i = dim; i--; ) {
          j = rowsol[i];
          u[i] = cost(i, j) - v[j];
          lapcost = lapcost + cost(i, j);
        }

        return {
          cost: lapcost,
          row: rowsol,
          col: colsol,
          u: u,
          v: v,
        };
      }
      function log(value, lvl) {
        document.querySelector("#console").innerText = value;
        console.log(value);
        if (lvl === "log") {
          document.querySelector("#console").style.backgroundColor = "#2196f3";
        }
        if (lvl === "error") {
          document.querySelector("#console").style.backgroundColor = "#B00020";
        }
      }
      function dropHandler(event) {
        event.preventDefault();
        const reader = new FileReader();
        //todo: implement file check
        console.log(event.dataTransfer.files[0]);
        reader.readAsText(event.dataTransfer.files[0]);
        reader.onload = function (e) {
          log("File Dropped!", "log");
          parseCSV(e.target.result);
        };
      }
      function dragOverHandler(event) {
        event.preventDefault();
      }
      function parseCSV(csv) {
        //todo: clear all values;
        let lines = csv.split("\n");
        console.log(lines);
        for (let i = 1; i < lines.length; i++) {
          let val = lines[i].split(",");
          names.push(val[0]);
          if (!isNaN(val[1])) {
            noOfDuty.push(Number(val[1]));
            totalDuty += Number(val[1]);
          }
          excludedResponses.push([val[7], val[8]]);
          responses.push([val[2], val[3], val[4], val[5], val[6]]);
        }
        //responses * no of duty
        for (let i = 0; i < responses.length; i++) {
          for (let x = 0; x < noOfDuty[i]; x++) {
            preferences.push(responses[i]);
            excluded.push(excludedResponses[i]);
            totalNames.push(names[i]);
          }
        }
        for (let i = 0; i < preferences.length; i++) {
          totalScores.push(getScoresArray(preferences[i], excluded[i]));
        }
        let result = lap(totalDuty, totalScores);
        log("Schedule Calculated!", "log");
        schedule = mapResultToName(result.row);
        console.log(schedule);
        let table = mapDutiesToTableFormat();
        //hide dropzone
        document.querySelector("#dropzone").setAttribute("hidden", true);
        createHTMLTable(table);
      }
      function getScoresArray(preference, excluded) {
        let pref = [];
        const scores = [30, 25, 22, 22, 35];
        for (let i = 0; i < totalDuty; i++) {
          pref.push(scores[Math.floor(Math.random() * scores.length)]);
        }
        for (let i = 0; i < preference.length; i++) {
          if (preference[i].length != 0) {
            pref[Number(preference[i]) - 1] = COST_VALUES[i];
          }
        }
        for (let i = 0; i < excluded.length; i++) {
          if (excluded[i].length != 0) {
            pref[Number(excluded[i]) - 1] = EXCLUDED_DATES_COST;
          }
        }
        return pref;
      }
      function mapResultToName(result) {
        let arr = [];
        for (let i = 0; i < names.length; i++) {
          let obj = {
            name: names[i],
            duties: [],
          };
          for (let x = 0; x < result.length; x++) {
            if (totalNames[x] === names[i]) {
              obj.duties.push(result[x] + 1);
            }
          }
          arr.push(obj);
        }
        return arr;
      }
      function mapDutiesToTableFormat() {
        let arr = [];
        let firstRow = [];
        firstRow.push("Name");
        for (let i = 0; i < totalDuty; i++) {
          firstRow.push(i + 1);
        }
        arr.push(firstRow);
        for (let i = 0; i < schedule.length; i++) {
          let curArr = [];
          curArr.push(schedule[i].name);
          for (let x = 0; x < totalDuty; x++) {
            curArr.push("");
          }
          for (let z = 0; z < schedule[i].duties.length; z++) {
            curArr[schedule[i].duties[z]] = 1;
          }
          arr.push(curArr);
        }
        return arr;
      }
      function createHTMLTable(tableArr) {
        let table = document.createElement("table");
        for (let i = 0; i < tableArr.length; i++) {
          let row = table.insertRow();
          for (let x = 0; x < tableArr[i].length; x++) {
            let cell = row.insertCell();
            cell.setAttribute("id", "id_" + i + "-" + x);
            cell.setAttribute(
              "onclick",
              'addReserve("id_' + i + "-" + x + '")'
            );
            cell.innerHTML = tableArr[i][x];
          }
        }
        document.querySelector("#editor").appendChild(table);
      }
      function addReserve(id) {
        let val = id.split("_")[1].split("-");
        if (val[0] == 0 || val[1] == 0) {
          return;
        }
        let cell = document.querySelector("#" + id);
        if (cell.innerHTML == 1) {
          return;
        }
        if (cell.innerHTML == "") {
          cell.innerHTML = "R";
          return;
        }
        if (cell.innerHTML == "R") {
          cell.innerHTML = "";
          return;
        }
      }
    </script>
  </body>
</html>
